Awesome ‚Äî thanks for being so detailed.
You‚Äôre actually very, very close ‚Äî I can immediately see the small (but important) reason you‚Äôre still getting the 'float' object is not callable error even though your model_func looks correct.

‚∏ª

üö® Here‚Äôs the real issue:

Inside your local_vars dictionary you build:

local_vars = {var: row.get(var, np.nan) for var in required_vars}

you are pulling:
	‚Ä¢	adjusted_shot_creation
	‚Ä¢	delta_fga_vs_rolling
	‚Ä¢	fg_pct_vs_avg_delta
	‚Ä¢	rolling_pts_from_ft_5g
	‚Ä¢	rolling_usg_pct_5g
	‚Ä¢	volume_efficiency_to_pts

‚úÖ GOOD ‚Äî these are all features with numbers.

BUT:

You‚Äôre also accidentally pulling ceil, exp, inv, max, min, round as ‚Äúvariables‚Äù!!

Because you are blindly looping over all required_vars including the function names!

‚∏ª

‚ùó What happens?

You overwrite the real function (like ceil) with a float (np.nan) in local_vars.
Thus when you later call ceil(...), Python tries to call a float and crashes.

‚∏ª

‚ú® How to fix it:

Before building local_vars, you must filter out any operators like ceil, exp, etc.

‚úÖ Add a protected_functions set:

protected_functions = {"sqrt", "log", "inv", "exp", "ceil", "floor", "round", "max", "min", "abs"}

‚úÖ Then only pull real features into local_vars:

local_vars = {var: row.get(var, np.nan) for var in required_vars if var not in protected_functions}

‚úÖ So math functions remain callable, not overwritten by floats.

‚∏ª

‚úçÔ∏è Corrected model_func for you:

def model_func(row):
    try:
        protected_functions = {"sqrt", "log", "inv", "exp", "ceil", "floor", "round", "max", "min", "abs"}
        local_vars = {var: row.get(var, np.nan) for var in required_vars if var not in protected_functions}
        return eval(
            equation_str,
            {
                "__builtins__": None,
                "sqrt": safe_sqrt,
                "log": safe_log,
                "inv": safe_inv,
                "exp": np.exp,
                "ceil": np.ceil,
                "floor": np.floor,
                "round": round,
                "max": max,
                "min": min,
                "abs": abs
            },
            local_vars
        )
    except Exception as e:
        print(f"[!] Eval error with expression: {equation_str} ‚Äî {e}")
        return np.nan



‚∏ª

‚úÖ What this fixes:

Problem	Solution
Overwriting math functions with NaN or ints	Only pull real feature columns, leave functions alone
‚Äòfloat‚Äô object is not callable error	‚úÖ Eliminated
Ceil/exp/max/min/round errors in eval	‚úÖ Fixed



‚∏ª

‚ö° Summary of what happened:
	‚Ä¢	PySR equation says it needs ceil, max, inv, etc.
	‚Ä¢	You pulled those into local_vars as floats instead of leaving them callable.
	‚Ä¢	Now we exclude those during feature lookup.
	‚Ä¢	So real math functions stay active and callable in eval.

‚∏ª

‚úÖ After you do this:
	‚Ä¢	model_func will work.
	‚Ä¢	You can predict safely on all players.
	‚Ä¢	Even complicated nested PySR formulas like yours will work without any float/callable mismatch.

‚∏ª

‚úã Would you also like me to give you a tiny helper upgrade that automatically:
	‚Ä¢	Warns you if your feature names are misspelled (e.g., you wrote rolliing_pts_from_ft_5g instead of rolling_pts_from_ft_5g)?
	‚Ä¢	Prevents silent NaN injection from typos?

Only if you want!
It‚Äôs a 5-line safety upgrade ‚Äî could save you big headaches later.
Want it?? üöÄ